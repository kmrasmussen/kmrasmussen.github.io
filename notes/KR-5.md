# KR 5: The network Layer: Control plane
Notes for Kurose & Ross 2017 by Kasper Rasmussen

Routers use forwarding tables with prefixes in order to determine which outgoing link a datagram should be going to. The control plane is responsible for making these forwarding tables using routing algorithms. These algorithms can either be run by the routers themselves or from some centralized place and sent to the routers.

Routing algorithms deal with graphs representing the network where the edges have weights representing a cost, fx the delay between the two routers. The algorithms can be centralized or decentralized. In decentralized algorithms the nodes have routers get information only from their neighbours. Dynamic routing algorithms, as opposed to static ones, change their routing paths as topology of the network changes without any human intervention. Load-sensitive algorithms, as opposed to insensitive ones, change the costs based on congestion, but this approach is not used in current protocols.

The link-state **LD** algorithm is a centralized one which uses Dijkstra's algorithm for shortest paths in graphs, so here they are synonymous. For a node $u$ the algorithm finds the shortest path from $u$ to all other nodes. It iteratively increases a set $N'$ which at first has only $u$ in it. For all the nodes inside we already know the shortest path. Each iteration we take the one outside on the border which has the shortest distance to $u$, call it $w$. We look at all the neighbors of $w$ which are outside and see if the shortest path to them are already known or if it goes through $w$. We track can track all these numbers in a table and continue untill there is no node left outside. 

The **distance-vector (DV)** algorithm is decentralized and is baled on the intuitive Bellman-Ford equation which is based on the fact that if a shortest path from A to D is A-B-C-D, then a shortest path from B to D must be B-C-D, otherwise when going from A to D why not first go to B then with that other shorter path to D? Let's say they are routers, then if B knows the shortest path to D then by telling this to A, A will know how fast it can get to D by going through B, if it just knows the cost of going to B. So the DV algorithm has all the costs to its negihbors and *distance vectors* from each of its neighbors specifying how far they have to everyone else. Based on the router can find out how fast it can get to some other router by comparing how fast it would be to go its different neighbours. The algorithm *converges*, it starts out imprecise but after many changes it all the nodes have the correct information.

In DV there is a problem called the **count-to-infinity**: I am a router and I get a lot of distance vectors from my neighbours specifying how far they are from anyone else. I use that to decide who I will go through to get to people, but actually some of them will decide to go through me. I might have 7 to Bob by going through Alice but suddenly Alice says she has 100 to Bob so I will not go through her. I see that my other neighbour Tom has only 9 to Bob. I have 2 to Tom so it will total 11 to Bob, which is much better. However, Tom said he had 9 to Bob because he would walk through me. He does not know I don't have 7 to Bob anymore. Now the count-to-infinity happens: Since I think I can actually get to Bob in 11, I need to send a new distance vector to Tom. He gets it and says: "Oh, now Kasper has 11 to Bob, so I must have 13 to Bob". Then he says that to me. I see that an say, "Oh, now Tom has 13 to Bob, so I must have 15" etc. Then I reach 99 and say that to Tom which tells me he has 101. Then I decide that Alice is probably better to go through and the problem stops.

The problem is avoided using **poisoned-reverse**. Since Tom originally was planning on going through me, he should not have told me that he had 9 to Bob, he should have told me that he has infinitely far to Bob! This would not cause any problems, since as long as he was going through me I could never get anywhere faster by going to him first and then back to me as we already discussed.